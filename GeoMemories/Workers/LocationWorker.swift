//
//  LocationWorker.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 18.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreLocation
import Combine

protocol LocationManagerProtocol: AnyObject {
    var authorizationStatus: CLAuthorizationStatus { get }
    var delegate: CLLocationManagerDelegate? { get set }
    func requestWhenInUseAuthorization()
    
    func requestLocation()
}

extension CLLocationManager: LocationManagerProtocol {}

enum LocationError: LocalizedError {
    case permissionDenied
    case failedToFetchLocation(Error)
    case unknown
    
    var errorDescription: String? {
        switch self {
        case .permissionDenied:
            return "Permission denied to access location"
        case .failedToFetchLocation(let error):
            return "Failed to fetch location: \(error.localizedDescription)"
        case .unknown:
            return "Unknown error"
        }
    }
}

class LocationWorker: NSObject, CLLocationManagerDelegate {
    private let locationManager: LocationManagerProtocol
    private let locationSubject = PassthroughSubject<CLLocation, Error>()
    
    private var lastLocation: CLLocation?
    private var lastLocationTimestamp: Date?
    private let cacheValidityDuration: TimeInterval = 5 * 60
    
    init(locationManager: LocationManagerProtocol = CLLocationManager()) {
        self.locationManager = locationManager
        super.init()
        self.locationManager.delegate = self
    }
    
    func getCurrentLocation() -> AnyPublisher<CLLocation, LocationError> {
        if let lastLocation = lastLocation,
           let lastLocationTimeStamp = lastLocationTimestamp,
           Date().timeIntervalSince(lastLocationTimeStamp) < cacheValidityDuration {
            return Just(lastLocation)
                .setFailureType(to: LocationError.self)
                .eraseToAnyPublisher()
        }
        
        return Future<Void, LocationError> { [weak self] promise in
            guard let self else { return promise(.failure(.unknown)) }
            
            switch self.locationManager.authorizationStatus {
            case .notDetermined:
                self.locationManager.requestWhenInUseAuthorization()
                promise(.success(()))
            case .restricted, .denied:
                promise(.failure(.permissionDenied))
            case .authorizedAlways, .authorizedWhenInUse:
                promise(.success(()))
            @unknown default:
                promise(.failure(.unknown))
            }
        }
        .flatMap { [weak self] () -> AnyPublisher<CLLocation, LocationError> in
            guard let self else {
                return Fail(error: LocationError.unknown).eraseToAnyPublisher()
            }
            
            self.locationManager.requestLocation()
            
            return self.locationSubject
                .mapError { .failedToFetchLocation($0) }
                .first()
                .eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
    }
    
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        switch manager.authorizationStatus {
        case .restricted, .denied:
            locationSubject.send(completion: .failure(LocationError.permissionDenied))
            lastLocation = nil
            lastLocationTimestamp = nil
        case .authorizedAlways, .authorizedWhenInUse:
            break
        default:
            break
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let location = locations.last {
            lastLocation = location
            lastLocationTimestamp = Date()
            
            locationSubject.send(location)
            locationSubject.send(completion: .finished)
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: any Error) {
        locationSubject.send(completion: .failure(error))
    }
}
