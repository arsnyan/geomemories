//
//  LocationWorker.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 18.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreLocation
import Combine
import MapKit
import OSLog

protocol LocationManagerProtocol: AnyObject {
    var authorizationStatus: CLAuthorizationStatus { get }
    var delegate: CLLocationManagerDelegate? { get set }
    func requestWhenInUseAuthorization()
    
    func requestLocation()
}

extension CLLocationManager: LocationManagerProtocol {}

protocol MKLocalSearchCompleterProtocol: AnyObject {
    var queryFragment: String { get set }
    var resultTypes: MKLocalSearchCompleter.ResultType { get set }
    var region: MKCoordinateRegion { get set }
    var delegate: MKLocalSearchCompleterDelegate? { get set }
}

extension MKLocalSearchCompleter: MKLocalSearchCompleterProtocol {}

enum LocationError: LocalizedError {
    case permissionDenied
    case failedToFetchLocation(Error)
    case failedToFindLocations(Error)
    case cachingError
    case unknown
    
    var errorDescription: String? {
        switch self {
        case .permissionDenied:
            "Permission denied to access location"
        case .failedToFetchLocation(let error):
            "Failed to fetch location: \(error.localizedDescription)"
        case .failedToFindLocations(let error):
            "Failed to find locations: \(error.localizedDescription)"
        case .cachingError:
            "Caching was not done correctly"
        case .unknown:
            "Unknown error"
        }
    }
}

class LocationWorker: NSObject {
    private let logger = Logger(subsystem: "GeoMemories", category: "LocationWorker")
    
    private let locationManager: LocationManagerProtocol
    private let locationSubject = PassthroughSubject<CLLocation, Error>()
    private let searchCompleter: MKLocalSearchCompleterProtocol
    private let completionSubject = PassthroughSubject<[MKLocalSearchCompletion], Error>()
    
    private var lastLocation: CLLocation?
    private var lastLocationTimestamp: Date?
    private let cacheValidityDuration: TimeInterval = 5 * 60
    
    init(
        locationManager: LocationManagerProtocol = CLLocationManager(),
        searchCompleter: MKLocalSearchCompleterProtocol = MKLocalSearchCompleter()
    ) {
        self.locationManager = locationManager
        self.searchCompleter = searchCompleter
        super.init()
        self.locationManager.delegate = self
        self.searchCompleter.delegate = self
//        self.searchCompleter.resultTypes = .
    }
    
    func getCurrentLocation() -> AnyPublisher<CLLocation, LocationError> {
        if let lastLocation = lastLocation,
           let lastLocationTimeStamp = lastLocationTimestamp,
           Date().timeIntervalSince(lastLocationTimeStamp) < cacheValidityDuration {
            return Just(lastLocation)
                .setFailureType(to: LocationError.self)
                .eraseToAnyPublisher()
        }
        
        return Future<Void, LocationError> { [weak self] promise in
            guard let self else { return promise(.failure(.unknown)) }
            
            switch self.locationManager.authorizationStatus {
            case .notDetermined:
                self.locationManager.requestWhenInUseAuthorization()
                promise(.success(()))
            case .restricted, .denied:
                promise(.failure(.permissionDenied))
            case .authorizedAlways, .authorizedWhenInUse:
                promise(.success(()))
            @unknown default:
                promise(.failure(.unknown))
            }
        }
        .flatMap { [weak self] () -> AnyPublisher<CLLocation, LocationError> in
            guard let self else {
                return Fail(error: LocationError.unknown).eraseToAnyPublisher()
            }
            
            self.locationManager.requestLocation()
            
            return self.locationSubject
                .mapError { .failedToFetchLocation($0) }
                .first()
                .eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
    }
    
    func findLocations(
        with query: String
    ) -> AnyPublisher<[MKMapItem], LocationError> {
        searchCompleter.queryFragment = query
        return completionSubject
            .mapError({ LocationError.failedToFindLocations($0) })
            .flatMap { completions -> AnyPublisher<[MKMapItem], LocationError> in
                let searches = completions.map { completion in
                    Future<MKMapItem?, LocationError> { promise in
                        let request = MKLocalSearch.Request(completion: completion)
                        
                        MKLocalSearch(request: request).start { response, error in
                            if let error {
                                promise(.failure(.failedToFindLocations(error)))
                            } else {
                                promise(.success(response?.mapItems.first))
                            }
                        }
                    }
                }
                
                return Publishers.MergeMany(searches)
                    .compactMap { $0 }
                    .collect()
                    .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }
}

extension LocationWorker: CLLocationManagerDelegate {
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        switch manager.authorizationStatus {
        case .restricted, .denied:
            locationSubject.send(completion: .failure(LocationError.permissionDenied))
            lastLocation = nil
            lastLocationTimestamp = nil
        case .authorizedAlways, .authorizedWhenInUse:
            break
        default:
            break
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let location = locations.last {
            lastLocation = location
            lastLocationTimestamp = Date()
            
            locationSubject.send(location)
            locationSubject.send(completion: .finished)
            
            let region = MKCoordinateRegion(
                center: location.coordinate,
                latitudinalMeters: 100000,
                longitudinalMeters: 100000
            )
            self.searchCompleter.region = region
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: any Error) {
        locationSubject.send(completion: .failure(error))
    }
}

extension LocationWorker: MKLocalSearchCompleterDelegate {
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
        completionSubject.send(completer.results)
    }
    
    func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: any Error) {
        completionSubject.send(completion: .failure(error))
        logger.error("\(error)")
    }
}
