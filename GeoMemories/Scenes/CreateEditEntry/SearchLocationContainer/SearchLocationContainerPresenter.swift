//
//  SearchLocationContainerPresenter.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 24.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import MapKit
import CoreLocation
import Contacts

protocol SearchLocationContainerPresentationLogic {
    func presentLocationSearchResults(response: SearchLocationContainer.SearchLocation.Response)
    func presentSelectedLocation(response: SearchLocationContainer.ChooseLocation.Response)
}

class SearchLocationContainerPresenter: SearchLocationContainerPresentationLogic {
    weak var viewController: SearchLocationContainerDisplayLogic?
    
    func presentLocationSearchResults(
        response: SearchLocationContainer.SearchLocation.Response
    ) {
        switch response {
        case .success(let results):
            let rows: [LocationCellViewModelProtocol] = results.isEmpty
                ? [LocationCellViewModel(mapItem: nil)]
                : results.prefix(5).compactMap { LocationCellViewModel(mapItem: $0) }
            
            viewController?.displayLocationSearchResults(
                viewModel: .success(results: rows)
            )
        case .failure(let error):
            let title: String
            let message: String
            
            switch error {
            case .failedToFindLocations(let error):
                title = String(localized: "genericErrorTitle")
                message = String(localized: "failedToFindLocationsMessage")
                    + error.localizedDescription
            case .unknown:
                title = String(localized: "error")
                message = String(localized: "unknownErrorMessage")
            default:
                return
            }
            
            viewController?.displayLocationSearchResults(
                viewModel: .failure(
                    alertTitle: title,
                    alertMessage: message
                )
            )
        case .userCancelled(let shouldClearTextField):
            viewController?.displayLocationSearchResults(viewModel: .userCancelled)
            if shouldClearTextField {
                viewController?.displaySelectedLocation(viewModel: .none)
            }
        }
        
        viewController?.detintCurrentLocationButton()
    }
    
    func presentSelectedLocation(
        response: SearchLocationContainer.ChooseLocation.Response
    ) {
        switch response {
        case .empty:
            viewController?.displaySelectedLocation(viewModel: .none)
            viewController?.detintCurrentLocationButton()
        case .successWithCurrentLocation(let location):
            locationToHumanReadableString(location) { [weak self] description in
                self?.viewController?.displaySelectedLocation(
                    viewModel: .success(
                        description: description
                    )
                )
            }
        case .successWithSelectedLocation(let mapItem):
            var description = ""
            if #available(iOS 26.0, *) {
                description = mapItem.address?.fullAddress
                    ?? coordinatesToString(mapItem.location.coordinate)
            } else {
                if let postalAddress = mapItem.placemark.postalAddress {
                    let formatter = CNPostalAddressFormatter()
                    description = formatter.string(from: postalAddress).replacingOccurrences(of: "\n", with: ", ")
                } else {
                    let placemark = mapItem.placemark
                    let addressParts = [
                        placemark.name, placemark.thoroughfare,
                        placemark.subThoroughfare, placemark.locality,
                        placemark.subAdministrativeArea, placemark.administrativeArea,
                        placemark.postalCode, placemark.country
                    ]
                    
                    description = addressParts.compactMap(\.self).joined(separator: ", ")
                }
            }
            
            viewController?.displaySelectedLocation(
                viewModel: .success(description: description)
            )
            viewController?.detintCurrentLocationButton()
        case .failure(let error):
            let title: String
            let message: String
            
            switch error {
            case .permissionDenied:
                title = String(localized: "locationServicesNotAuthorizedTitle")
                message = String(localized: "locationServicesNotAuthorizedMessage")
            case .failedToFetchLocation(let error):
                title = String(localized: "error")
                message = String(localized: "noLocalizedErrorMessage") + "\n" + error.localizedDescription
            case .failedToFindLocations(let error):
                title = String(localized: "error")
                message = String(localized: "failedToFindLocationsMessage") + "\n" + error.localizedDescription
            default:
                title = String(localized: "genericErrorTitle")
                message = String(localized: "unknownErrorMessage")
            }
            
            viewController?.displaySelectedLocation(
                viewModel: .failure(
                    alertTitle: title,
                    alertMessage: message
                )
            )
            viewController?.detintCurrentLocationButton()
        }
        
        viewController?.displayLocationSearchResults(viewModel: .userCancelled)
    }
    
    func coordinatesToString(_ coord: CLLocationCoordinate2D) -> String {
        let lat = coord.latitude
        let lng = coord.longitude
        // Always show the sign (+ or -) of the coordinate regex
        return String(format: "%+.6f, %+.6f", lat, lng)
    }
    
    func locationToHumanReadableString(
        _ location: CLLocation,
        completion: @escaping (String) -> Void
    ) {
        if #available(iOS 26.0, *) {
            Task {
                if let request = MKReverseGeocodingRequest(location: location) {
                    let mapItems = try? await request.mapItems
                    if let mapItem = mapItems?.first {
                        let fullAddress = mapItem.address?.fullAddress
                        await MainActor.run {
                            completion(
                                fullAddress ?? coordinatesToString(location.coordinate)
                            )
                        }
                    }
                }
            }
        } else {
            let geoCoder = CLGeocoder()
            geoCoder.reverseGeocodeLocation(location) { [weak self] placemarks, _ in
                if let placemark = placemarks?.first {
                    let addressParts = [
                        placemark.name, placemark.thoroughfare,
                        placemark.subThoroughfare, placemark.locality,
                        placemark.subAdministrativeArea, placemark.administrativeArea,
                        placemark.postalCode, placemark.country
                    ]
                    
                    let nonEmptyAddressParts = addressParts.compactMap(\.self)
                    completion(nonEmptyAddressParts.joined(separator: ", "))
                } else {
                    completion(self?.coordinatesToString(location.coordinate) ?? "")
                }
            }
        }
    }
}
