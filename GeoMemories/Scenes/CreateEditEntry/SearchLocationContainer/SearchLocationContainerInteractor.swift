//
//  SearchLocationContainerInteractor.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 24.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreLocation
import Combine
import MapKit
import OSLog
import CoreStore

protocol SearchLocationContainerDelegate: AnyObject {
    func didUpdateLocation(coordinate: CLLocationCoordinate2D?)
}

protocol SearchLocationContainerBusinessLogic {
    func loadInitialLocation()
    func provideLocationSearchResults(request: SearchLocationContainer.SearchLocation.Request)
    func selectLocation(request: SearchLocationContainer.ChooseLocation.Request)
    
    var delegate: SearchLocationContainerDelegate? { get set }
}

protocol SearchLocationContainerDataStore {
    var geoEntry: GeoEntry? { get set }
}

class SearchLocationContainerInteractor: SearchLocationContainerBusinessLogic, SearchLocationContainerDataStore {
    private let logger = Logger(subsystem: "GeoMemories", category: "SearchLocationContainerInteractor")
    private var cancellables = Set<AnyCancellable>()
    
    var presenter: SearchLocationContainerPresentationLogic?
    var locationWorker: LocationWorker? = LocationWorker()
    
    weak var delegate: SearchLocationContainerDelegate?
    var geoEntry: GeoEntry?
    
    private let cachedSearchResults = NSCache<NSString, NSArray>()
    
    private var isCurrentLocationSelected: Bool = false
    
    func loadInitialLocation() {
        guard let geoEntry else { return }
        
        Dependencies.dataStack.perform { [weak self] transaction in
            guard let existing = transaction.fetchExisting(geoEntry) else { return }
            
            let location = CLLocation(
                latitude: existing.latitude,
                longitude: existing.longitude
            )
            self?.presenter?.presentSelectedLocation(
                response: .successWithCurrentLocation(location: location)
            )
        } completion: { [weak self] result in
            if case let .failure(error) = result {
                self?.logger.error("Something went wrong while fetching geo entry: \(error)")
            }
        }
    }
    
    func provideLocationSearchResults(
        request: SearchLocationContainer.SearchLocation.Request
    ) {
        isCurrentLocationSelected = false
        
        switch request {
        case .cancelled(let userInitiated):
            presenter?.presentLocationSearchResults(
                response: .userCancelled(shouldClearTextField: userInitiated)
            )
        case .clear:
            presenter?.presentLocationSearchResults(response: .success(results: []))
        case .search(let query):
            if let genericCachedResults = cachedSearchResults.object(
                forKey: NSString(string: query)
            ) {
                guard let cachedResults = genericCachedResults
                        as? [MKMapItem] else {
                    presenter?.presentLocationSearchResults(
                        response: .failure(error: .cachingError)
                    )
                    logger.error(
                        "Failed to transform cached results for query: \(query)"
                    )
                    return
                }
                
                logger.trace("Found a cached result for query: \(query)")
                
                presenter?.presentLocationSearchResults(
                    response: .success(results: cachedResults)
                )
                return
            }
            
            logger.trace("No cached result for query: \(query). Requesting from MapKit")
            
            locationWorker?.findLocations(with: query)
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { [weak self] completion in
                        if case .failure(let error) = completion {
                            self?.logger.error("\(error)")
                            self?.presenter?.presentLocationSearchResults(
                                response: .failure(error: error)
                            )
                        }
                    },
                    receiveValue: { [weak self] mapItems in
                        self?.cachedSearchResults.setObject(
                            mapItems as NSArray,
                            forKey: NSString(string: query)
                        )
                        
                        self?.presenter?.presentLocationSearchResults(
                            response: .success(results: mapItems)
                        )
                    }
                )
                .store(in: &cancellables)
        }
    }
    
    func selectLocation(request: SearchLocationContainer.ChooseLocation.Request) {
        switch request {
        case .manual(let row):
            guard let mapItem = row.mapItem else {
                return
            }
            
            isCurrentLocationSelected = false
            if #available(iOS 26.0, *) {
                delegate?.didUpdateLocation(coordinate: mapItem.location.coordinate)
            } else {
                delegate?.didUpdateLocation(coordinate: mapItem.placemark.coordinate)
            }
            presenter?.presentSelectedLocation(
                response: .successWithSelectedLocation(mapItem: mapItem)
            )
        case .current:
            if isCurrentLocationSelected {
                isCurrentLocationSelected.toggle()
                delegate?.didUpdateLocation(coordinate: nil)
                presenter?.presentSelectedLocation(response: .empty)
            } else {
                locationWorker?.getCurrentLocation()
                    .sink(
                        receiveCompletion: { [weak self] completion in
                            if case let .failure(error) = completion {
                                self?.logger.error("\(error)")
                                self?.delegate?.didUpdateLocation(coordinate: nil)
                                self?.presenter?.presentSelectedLocation(
                                    response: .failure(error: error)
                                )
                            }
                        },
                        receiveValue: { [weak self] location in
                            self?.isCurrentLocationSelected.toggle()
                            self?.delegate?.didUpdateLocation(coordinate: location.coordinate)
                            self?.presenter?.presentSelectedLocation(
                                response: .successWithCurrentLocation(location: location)
                            )
                        }
                    )
                    .store(in: &cancellables)
            }
        }
    }
}
