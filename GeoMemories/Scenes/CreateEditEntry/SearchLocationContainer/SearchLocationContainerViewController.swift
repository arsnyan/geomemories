//
//  SearchLocationContainerViewController.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 24.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SnapKit

protocol SearchLocationContainerDisplayLogic: AnyObject {
    func displayLocationSearchResults(viewModel: SearchLocationContainer.SearchLocation.ViewModel)
    func displaySelectedLocation(viewModel: SearchLocationContainer.ChooseLocation.ViewModel)
    func detintCurrentLocationButton()
}

class SearchLocationContainerViewController: UIViewController {
    var interactor: SearchLocationContainerBusinessLogic?
    var router: (NSObjectProtocol & SearchLocationContainerRoutingLogic & SearchLocationContainerDataPassing)?
    
    private var searchTimer: Timer?
    private var endEditingUserInitiated: Bool = true
    private var locationRows: [LocationCellViewModelProtocol] = [] {
        didSet {
            resultsTable.reloadData()
            
            resultsTable.snp.updateConstraints { make in
                make.height.equalTo(locationRows.map(\.height).reduce(0, +))
            }
            
            UIView.animate(
                withDuration: 0.3,
                delay: 0,
                usingSpringWithDamping: 0.8,
                initialSpringVelocity: 0
            ) {
                self.view.layoutIfNeeded()
            } completion: { _ in
                if self.locationRows.isEmpty {
                    self.container.backgroundColor = .clear
                } else {
                    self.container.backgroundColor = .gray.withAlphaComponent(0.05)
                }
            }
        }
    }
    
    private var container: UIView!
    private var searchBarStack: UIStackView!
    private var searchTextField: UITextField!
    private var currentLocationButton: UIButton!
    private var resultsTable: UITableView!
    
    // MARK: View lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        searchTextField.resignFirstResponder()
    }
}

extension SearchLocationContainerViewController: SearchLocationContainerDisplayLogic {
    func displayLocationSearchResults(
        viewModel: SearchLocationContainer.SearchLocation.ViewModel
    ) {
        endEditingUserInitiated = true
        
        switch viewModel {
        case .success(let results):
            locationRows = results
        case .userCancelled:
            locationRows = []
        case .failure(let alertTitle, let alertMessage):
            locationRows = []
            showAlert(with: alertTitle, message: alertMessage)
        }
    }
    
    func displaySelectedLocation(viewModel: SearchLocationContainer.ChooseLocation.ViewModel) {
        endEditingUserInitiated = false
        searchTextField.resignFirstResponder()
        
        switch viewModel {
        case .success(let description):
            setTextAnimated(description)
        case .none:
            setTextAnimated(nil)
        case .failure(let alertTitle, let alertMessage):
            showAlert(with: alertTitle, message: alertMessage)
        }
    }
    
    func detintCurrentLocationButton() {
        currentLocationButton.tintColor = .systemGray
    }
}

// MARK: - UI Components Configuration
private extension SearchLocationContainerViewController {
    func setupUI() {
        configureContainer()
    }
    
    func configureCurrentLocationButton() {
        var config: UIButton.Configuration
        
        if #available(iOS 26.0, *) {
            config = .glass()
        } else {
            config = .tinted()
            config.cornerStyle = .capsule
        }
        config.image = UIImage(systemName: "location.fill")
        config.buttonSize = .mini
        
        currentLocationButton = UIButton(configuration: config)
        currentLocationButton.tintColor = .systemGray3
        currentLocationButton.accessibilityLabel = String(
            localized: "getCurrentLocationButtonActionTitle"
        )
        
        currentLocationButton.addTarget(
            self,
            action: #selector(currentLocationTapped),
            for: .touchUpInside
        )
        
        currentLocationButton.snp.makeConstraints { make in
            make.width.equalTo(44)
        }
    }
    
    func configureSearchTextField() {
        searchTextField = RoundedCornersTextField()
        searchTextField.placeholder = String(localized: "locationSearchFieldPlaceholder")
        searchTextField.clearButtonMode = .whileEditing
        searchTextField.returnKeyType = .search
        searchTextField.layer.cornerRadius = 22
        
        if #available(iOS 26.0, *) {
            searchTextField.backgroundColor = .systemGray6
        } else {
            searchTextField.backgroundColor = .systemBackground
            searchTextField.layer.shadowColor = UIColor.black.cgColor
            searchTextField.layer.shadowRadius = 4
            searchTextField.layer.shadowOffset = CGSize(width: 0, height: 2)
            searchTextField.layer.shadowOpacity = 0.1
        }
        
        let icon = UIImage(systemName: "magnifyingglass")
        searchTextField.leftView = UIImageView(image: icon)
        searchTextField.leftView?.tintColor = .systemGray
        searchTextField.leftViewMode = .always
        
        searchTextField.delegate = self
        searchTextField.addTarget(
            self,
            action: #selector(handleLocationSearchTextChange),
            for: .editingChanged
        )
    }
    
    func configureSearchBarStack() {
        configureSearchTextField()
        configureCurrentLocationButton()
        
        searchBarStack = UIStackView(arrangedSubviews: [searchTextField, currentLocationButton])
        searchBarStack.axis = .horizontal
        searchBarStack.distribution = .fill
        searchBarStack.spacing = 8
        searchBarStack.alignment = .fill
    }
    
    func configureResultsView() {
        resultsTable = UITableView()
        resultsTable.backgroundColor = .clear
        resultsTable.separatorStyle = .none
        resultsTable.showsVerticalScrollIndicator = false
        resultsTable.delegate = self
        resultsTable.dataSource = self
        resultsTable.register(
            LocationCellView.self,
            forCellReuseIdentifier: LocationCellView.reuseIdentifier
        )
    }
    
    func configureContainer() {
        configureSearchBarStack()
        configureResultsView()
        
        container = UIView()
        container.addSubview(searchBarStack)
        container.addSubview(resultsTable)
        container.layer.cornerRadius = 22
        view.addSubview(container)
        
        searchBarStack.snp.makeConstraints { make in
            make.height.equalTo(44)
            make.top.leading.trailing.equalToSuperview()
        }
        
        resultsTable.snp.makeConstraints { make in
            make.top.equalTo(searchBarStack.snp.bottom)
            make.leading.trailing.equalToSuperview()
            make.height.equalTo(0)
        }
        
        container.snp.makeConstraints { make in
            // TODO: - Remove that as this should be done in parent view
            make.leading.trailing.equalToSuperview().inset(16)
            make.top.equalTo(view.safeAreaLayoutGuide.snp.top).offset(16)
            // TODO: - But not this
            make.bottom.equalTo(resultsTable.snp.bottom)
        }
    }
}

// MARK: - Private Helper Methods
private extension SearchLocationContainerViewController {
    func showAlert(with title: String, message: String, performing actions: [UIAlertAction] = []) {
        let alertController = UIAlertController(
            title: title,
            message: message,
            preferredStyle: .alert
        )
        actions.forEach { alertController.addAction($0) }
        alertController.addAction(
            UIAlertAction(
                title: String(localized: "ok"),
                style: .default
            )
        )
        present(alertController, animated: true)
    }
    
    func setTextAnimated(_ text: String?) {
        let animation = CATransition()
        animation.duration = 0.2
        animation.type = .fade
        animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        searchTextField.layer.add(animation, forKey: "fadeText")
        searchTextField.text = text
    }
}

// MARK: - Selector Methods
@objc private extension SearchLocationContainerViewController {
    func handleLocationSearchTextChange(_ textField: UITextField) {
        searchTimer?.invalidate()
        currentLocationButton.tintColor = .systemGray
        
        guard let text = textField.text,
              !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            interactor?.provideLocationSearchResults(request: .clear)
            return
        }
        
        var timeInterval: TimeInterval {
            #if DEBUG
            2
            #else
            1
            #endif
        }
        
        searchTimer = Timer.scheduledTimer(
            withTimeInterval: timeInterval,
            repeats: false,
            block: { [weak self] _ in
                self?.interactor?.provideLocationSearchResults(
                    request: .search(query: text)
                )
            }
        )
    }
    
    func currentLocationTapped() {
        currentLocationButton.tintColor = .systemBlue
        interactor?.selectLocation(request: .current)
    }
}

extension SearchLocationContainerViewController: UITextFieldDelegate {
    func textFieldDidBeginEditing(_ textField: UITextField) {
        // I decided I want the text field to empty any time the user click on it
        // as an intent of making a new search, so that they don't need to do it
        // manually all the time
        textField.text = nil
    }
    
    func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
        interactor?.provideLocationSearchResults(
            request: .cancelled(
                userInitiated: endEditingUserInitiated
            )
        )
        return true
    }
    
    func textFieldShouldClear(_ textField: UITextField) -> Bool {
        interactor?.provideLocationSearchResults(
            request: .cancelled(userInitiated: endEditingUserInitiated)
        )
        return true
    }
}

extension SearchLocationContainerViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        locationRows[indexPath.row].height
    }
    
    func tableView(_ tableView: UITableView, willSelectRowAt indexPath: IndexPath) -> IndexPath? {
        let viewModel = locationRows[indexPath.row]
        return viewModel.isSelectable ? indexPath : nil
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let row = locationRows[indexPath.row]
        interactor?.selectLocation(request: .manual(row: row))
    }
}

extension SearchLocationContainerViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        locationRows.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(
            withIdentifier: LocationCellView.reuseIdentifier,
            for: indexPath
        ) as? LocationCellView else {
            return UITableViewCell()
        }
        let row = locationRows[indexPath.row]
        cell.viewModel = row
        return cell
    }
}
