//
//  CreateEditEntryInteractor.swift
//  GeoMemories
//
//  Created by Арсен Саруханян on 20.08.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import Foundation
import CoreLocation
import Combine
import MapKit
import OSLog

enum CreateEditEntryError: LocalizedError {
    case failedToTransformCache
    
    var errorDescription: String {
        switch self {
        case .failedToTransformCache:
            "The cached search results were not transformed correctly, thus they're not saved correctly too"
        }
    }
}

protocol CreateEditEntryBusinessLogic {
    func provideNavigationBarTitle()
    func provideLocationSearchResults(request: CreateEditEntry.SearchLocation.Request)
    func selectLocation(request: CreateEditEntry.ChooseLocation.Request)
}

protocol CreateEditEntryDataStore {
    var entry: GeoEntry? { get set }
}

class CreateEditEntryInteractor: CreateEditEntryBusinessLogic, CreateEditEntryDataStore {
    private let logger = Logger(subsystem: "GeoMemories", category: "CreateEditEntryInteractor")
    private var cancellables = Set<AnyCancellable>()
    
    var entry: GeoEntry?
    
    var presenter: CreateEditEntryPresentationLogic?
    var worker: CreateEditEntryWorker?
    var locationWorker: LocationWorker?
    
    private let cachedSearchResults = NSCache<NSString, NSArray>()
    
    func provideNavigationBarTitle() {
        presenter?.presentNavigationBarTitle(response: .init(isEditMode: entry != nil))
    }
    
    func provideLocationSearchResults(request: CreateEditEntry.SearchLocation.Request) {
        switch request {
        case .cancelled:
            presenter?.presentLocationSearchResults(response: .userCancelled)
        case .clear:
            presenter?.presentLocationSearchResults(response: .success(results: []))
        case .search(let query):
            if let genericCachedResults = cachedSearchResults.object(
                forKey: NSString(string: query)
            ) {
                guard let cachedResults = genericCachedResults
                        as? [MKMapItem] else {
                    presenter?.presentLocationSearchResults(
                        response: .failure(error: .cachingError)
                    )
                    logger.trace(
                        "Failed to transform cached results for query: \(query)"
                    )
                    return
                }
                
                logger.trace("Found a cached result for query: \(query)")
                
                presenter?.presentLocationSearchResults(
                    response: .success(results: cachedResults)
                )
                return
            }
            
            logger.trace("No cached result for query: \(query). Requesting from MapKit")
            
            locationWorker?.findLocations(with: query)
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { [weak self] completion in
                        if case .failure(let error) = completion {
                            self?.presenter?.presentLocationSearchResults(
                                response: .failure(error: error)
                            )
                        }
                    },
                    receiveValue: { [weak self] mapItems in
                        self?.cachedSearchResults.setObject(
                            mapItems as NSArray,
                            forKey: NSString(string: query)
                        )
                        
                        self?.presenter?.presentLocationSearchResults(
                            response: .success(results: mapItems)
                        )
                    }
                )
                .store(in: &cancellables)
        }
    }
    
    func selectLocation(request: CreateEditEntry.ChooseLocation.Request) {
        switch request {
        case .abort:
            presenter?.presentSelectedLocation(response: .empty)
        case .manual(let row):
            guard let mapItem = row.mapItem else {
                return
            }
            
            presenter?.presentSelectedLocation(
                response: .successWithSelectedLocation(mapItem: mapItem)
            )
        case .current:
            locationWorker?.getCurrentLocation()
                .sink(
                    receiveCompletion: { [weak self] completion in
                        if case let .failure(error) = completion {
                            self?.presenter?.presentSelectedLocation(
                                response: .failure(error: error)
                            )
                        }
                    },
                    receiveValue: { [weak self] location in
                        self?.presenter?.presentSelectedLocation(
                            response: .successWithCurrentLocation(location: location)
                        )
                    }
                )
                .store(in: &cancellables)
        }
    }
}
